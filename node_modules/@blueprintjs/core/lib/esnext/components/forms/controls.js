/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the terms of the LICENSE file distributed with this project.
 */
// we need some empty interfaces to show up in docs
// HACKHACK: these components should go in separate files
// tslint:disable max-classes-per-file no-empty-interface
import classNames from "classnames";
import * as React from "react";
import * as Classes from "../../common/classes";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { safeInvoke } from "../../common/utils";
/**
 * Renders common control elements, with additional props to customize appearance.
 * This component is not exported and is only used in this file for `Checkbox`, `Radio`, and `Switch` below.
 */
const Control = ({ alignIndicator, children, className, inline, inputRef, label, labelElement, large, style, type, typeClassName, tagName: TagName = "label", ...htmlProps }) => {
    const classes = classNames(Classes.CONTROL, typeClassName, {
        [Classes.DISABLED]: htmlProps.disabled,
        [Classes.INLINE]: inline,
        [Classes.LARGE]: large,
    }, Classes.alignmentClass(alignIndicator), className);
    return (React.createElement(TagName, { className: classes, style: style },
        React.createElement("input", Object.assign({}, htmlProps, { ref: inputRef, type: type })),
        React.createElement("span", { className: Classes.CONTROL_INDICATOR }),
        label,
        labelElement,
        children));
};
export class Switch extends React.PureComponent {
    render() {
        return React.createElement(Control, Object.assign({}, this.props, { type: "checkbox", typeClassName: Classes.SWITCH }));
    }
}
Switch.displayName = `${DISPLAYNAME_PREFIX}.Switch`;
export class Radio extends React.PureComponent {
    render() {
        return React.createElement(Control, Object.assign({}, this.props, { type: "radio", typeClassName: Classes.RADIO }));
    }
}
Radio.displayName = `${DISPLAYNAME_PREFIX}.Radio`;
export class Checkbox extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            indeterminate: this.props.indeterminate || this.props.defaultIndeterminate || false,
        };
        this.handleChange = (evt) => {
            const { indeterminate } = evt.target;
            // update state immediately only if uncontrolled
            if (this.props.indeterminate == null) {
                this.setState({ indeterminate });
            }
            // otherwise wait for props change. always invoke handler.
            safeInvoke(this.props.onChange, evt);
        };
        this.handleInputRef = (ref) => {
            this.input = ref;
            safeInvoke(this.props.inputRef, ref);
        };
    }
    render() {
        const { defaultIndeterminate, indeterminate, ...controlProps } = this.props;
        return (React.createElement(Control, Object.assign({}, controlProps, { inputRef: this.handleInputRef, onChange: this.handleChange, type: "checkbox", typeClassName: Classes.CHECKBOX })));
    }
    componentWillReceiveProps({ indeterminate }) {
        // put props into state if controlled by props
        if (indeterminate != null) {
            this.setState({ indeterminate });
        }
    }
    componentDidMount() {
        this.updateIndeterminate();
    }
    componentDidUpdate() {
        this.updateIndeterminate();
    }
    updateIndeterminate() {
        if (this.state.indeterminate != null) {
            this.input.indeterminate = this.state.indeterminate;
        }
    }
}
Checkbox.displayName = `${DISPLAYNAME_PREFIX}.Checkbox`;
//# sourceMappingURL=controls.js.map